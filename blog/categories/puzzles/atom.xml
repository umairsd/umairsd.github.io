<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Puzzles | Umair's blog]]></title>
  <link href="http://umairsd.github.io/blog/categories/puzzles/atom.xml" rel="self"/>
  <link href="http://umairsd.github.io/"/>
  <updated>2015-05-17T07:49:36-07:00</updated>
  <id>http://umairsd.github.io/</id>
  <author>
    <name><![CDATA[Umair Saeed]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A Quine in Objective-C]]></title>
    <link href="http://umairsd.github.io/blog/2012/07/18/a-quine-in-objective-c/"/>
    <updated>2012-07-18T06:46:06-07:00</updated>
    <id>http://umairsd.github.io/blog/2012/07/18/a-quine-in-objective-c</id>
    <content type="html"><![CDATA[<p>A quine is a program that takes no input and outputs its own source code. It has been a while since I last wrote a quine, so I figured I&rsquo;ll write one in Objective-C. In general, quines follow a fairly simple formula. The program contains a string that includes all the code before the string and all the code after the string. Depending on the programming language, the string might also contain format string (for languages that use format-strings to print to stdout)</p>

<!-- More -->


<p>Here is the code for the quine. I&rsquo;ve broken the code below into segments to make it simpler to understand:</p>

<pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;  
int main (int argc, const char * argv[]) { 
    @autoreleasepool 
    { 
        NSString *str=@" \
            #import &lt;Foundation/Foundation.h&gt; %c \
            int main (int argc, const char * argv[]) { @autoreleasepool { NSString *str= \
            %c%c%@%c; \
            NSLog(str, 10, 64, 34, str, 34);} return 0;}";
        NSLog(str, 10, 64, 34, str, 34); 
    } 
    return 0;
}
</code></pre>

<p>Before I go on, 10, 64 and 34 are the ASCII character codes for <code>newline</code>, <code>@</code>and <code>"</code>respectively. To make it clearer, I&rsquo;ve broken the string into four lines. The first two lines contain the source code before the string. The 3rd line is the format string and the last line is the source code after the string. Here&rsquo;s the code with all lines collapsed:</p>

<pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;  
int main (int argc, const char * argv[]) { 
    @autoreleasepool 
    { 
        NSString *str=@"#import &lt;Foundation/Foundation.h&gt; %c int main (int argc, const char * argv[]) { @autoreleasepool { NSString *str=%c%c%@%c; NSLog(str, 10, 64, 34, str, 34);} return 0;}";
        NSLog(str, 10, 64, 34, str, 34); 
    } 
    return 0;
}
</code></pre>

<p>Finally, here&rsquo;s the output when you execute this program. As you can tell, this is the same as the original program (minus the whitespace)</p>

<pre><code class="objc">#import &lt;Foundation/Foundation.h&gt; 
 int main (int argc, const char * argv[]) { @autoreleasepool { NSString *str=@"#import &lt;Foundation/Foundation.h&gt; %c int main (int argc, const char * argv[]) { @autoreleasepool { NSString *str=%c%c%@%c; NSLog(str, 10, 64, 34, str, 34);} return 0;}"; NSLog(str, 10, 64, 34, str, 34);} return 0;}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stern-Brocot Tree]]></title>
    <link href="http://umairsd.github.io/blog/2011/01/27/stern-brocot-tree/"/>
    <updated>2011-01-27T05:56:15-08:00</updated>
    <id>http://umairsd.github.io/blog/2011/01/27/stern-brocot-tree</id>
    <content type="html"><![CDATA[<p>Stern-Brocot tree is a tree data structure whose vertices correspond to the set of non-negative rational numbers. Thus, this tree provides a very elegant way for constructing the set of fractions <code>m/n</code>, where <code>m</code> and <code>n</code> are relatively prime. To construct the tree, the basic idea is to start with two fractions (<code>0/1</code>, <code>1/0</code>) and then repeat the following operation:</p>

<p><strong>Insert (m+m&#8217;)/(n+n&#8217;) between two adjacent fractions m/n and m&#8217;/n&#8217;</strong></p>

<!-- More -->


<p>The first step gives us the entry <code>1/1</code> between <code>0/1</code> and <code>1/0</code>. Similarly, the 2nd step gives us two more: <code>0/1</code>, <code>1/2</code>, <code>1/1</code>, <code>2/1</code>, <code>1/0</code>.</p>

<p>Continuing on like this results in an infinite binary search tree which preserves the usual ordering of rational numbers.</p>

<p>The figure below shows the 1st 4 levels of the Stern-Brocot tree.</p>

<p><img class="center" src="/images/stern-brocot.png" title="Stern-brocot" ></p>

<p style="text-align:center;"> <em>The first 4 levels of Stern-Brocot Tree</em></p>

<h3>Finding the Path to k in Stern-Brocot Tree</h3>

<p>The path from the root of the tree to a number <code>k</code> in the Stern-Brocot tree can be found using binary search. At each node, <code>k</code> will either be in the left half of the tree, or the right half. We continue down the left or right subtree until we finally find <code>k</code>.</p>

<ul>
<li>Initialize the left fraction <code>L</code> to <code>0/1</code> and right fraction <code>R</code> to <code>1/0</code></li>
<li>Repeat the following until <code>k</code> is found:

<ul>
<li>Compute the mediant <code>M</code> (which is <code>(m+m')/(n+n')</code> )</li>
<li>If <code>(k&gt;M)</code>, then <code>k</code> is in the right half of the tree. <code>L:=M</code> and continue.</li>
<li>Else If <code>(M&gt;k)</code>, then <code>k</code> is in the left half of the tree. <code>R:=M</code> and continue.</li>
<li>Else <code>k=M</code>, terminate search.</li>
</ul>
</li>
</ul>


<h3>Implementation</h3>

<p>There&rsquo;s a couple of things to tackle in our implementation. First, I need an easy way to represent fractions, so I create my own <code>SternBrocotFraction</code> class. I deliberately chose to make it very specific to this algorithm because I needed a special way to handle the fraction 1/0 (which by definition is greater than all other rationals).</p>

<p>Secondly, I needed a good way to represent the path from the root of the tree to k. I do this by using a <code>StringBuilder</code>, and at each step I append either the letter <code>L</code> or <code>R</code> depending on which sub-tree we take. When the search is finished, this gives us a string representation of the path from the root of the tree to the number <code>k</code>. This approach is similar to the approach advocated by ACM Programming Competitions for <a href="http://acm.uva.es/p/v100/10077.html">the &ldquo;Stern-Brocot Number System&rdquo; problem</a>.</p>

<p>Here&rsquo;s the code to find path to a number k:</p>

<pre><code class="java">package com.umairsaeed.algorithm;

public class SternBrocotPath {
    private static final char LEFT_SUB = 'L';
    private static final char RIGHT_SUB = 'R';

    public String findPathTo(SternBrocotFraction f) {
        SternBrocotFraction L = new SternBrocotFraction(0, 1);
        SternBrocotFraction R = new SternBrocotFraction(1, 0);

        StringBuilder results = new StringBuilder();
        SternBrocotPath.find(f, L, R, results);
        return results.toString();
    }

    public static void find(SternBrocotFraction f,
            SternBrocotFraction L,
            SternBrocotFraction R,
            StringBuilder results)
    {
        SternBrocotFraction M = L.add(R);

        if (M.compareTo(f) &lt; 0) {
            L = M;
            results.append(RIGHT_SUB);
            SternBrocotPath.find(f, L, R, results);
        } else if (M.compareTo(f) &gt; 0) {
            R = M;
            results.append(LEFT_SUB);
            SternBrocotPath.find(f, L, R, results);
        }
        return;
    }
}
</code></pre>

<p>The special <code>SternBrocotFraction</code> class is:</p>

<pre><code class="java">package com.umairsaeed.algorithm;

public class SternBrocotFraction implements
                Comparable&lt;SternBrocotFraction&gt; {
    private int numerator;
    private int denominator;

    public SternBrocotFraction(int numerator, int denominator) {
        if (denominator &lt; 0) {
            numerator *= -1;
            denominator *= -1;
        }

        this.numerator = numerator;
        this.denominator = denominator;
    }

    public double doubleValue() {
        if (this.denominator == 0) {
            return Double.MAX_VALUE;
        } else {
            return (double) this.numerator /
                        (double) this.denominator;
        }
    }

    public SternBrocotFraction add(SternBrocotFraction other) {
        return new SternBrocotFraction(
                this.numerator + other.numerator,
                this.denominator + other.denominator);
    }

    public int compareTo(SternBrocotFraction other) {
        if (this.doubleValue() &lt; other.doubleValue()) {
            return -1;
        } else if (this.doubleValue() &gt; other.doubleValue()) {
            return 1;
        }
        return 0;
    }
}
</code></pre>

<p>Finally, some test code to exercise my class:</p>

<pre><code class="java">package com.umairsaeed.algorithm;

public class SternBrocotTester {
    public static void main(String[] args) {
        testSternBrocotPath();
    }

    public static void testSternBrocotPath() {
        SternBrocotPath t = new SternBrocotPath();

        SternBrocotFraction f = new SternBrocotFraction(5, 7);
        System.out.println(t.findPathTo(f));

        f = new SternBrocotFraction(19, 101);
        System.out.println(t.findPathTo(f));

        f = new SternBrocotFraction(977, 331);
        System.out.println(t.findPathTo(f));

        f = new SternBrocotFraction(1049, 7901);
        System.out.println(t.findPathTo(f));
    }
}
</code></pre>
]]></content>
  </entry>
  
</feed>
