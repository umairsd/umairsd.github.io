<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Umair's blog]]></title>
  <link href="http://umairsd.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://umairsd.github.io/"/>
  <updated>2015-03-26T11:47:49-07:00</updated>
  <id>http://umairsd.github.io/</id>
  <author>
    <name><![CDATA[Umair Saeed]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Finding the Start of a Loop in a Circular Linked List]]></title>
    <link href="http://umairsd.github.io/blog/2011/06/23/finding-the-start-of-a-loop-in-a-circular-linked-list/"/>
    <updated>2011-06-23T06:54:07-07:00</updated>
    <id>http://umairsd.github.io/blog/2011/06/23/finding-the-start-of-a-loop-in-a-circular-linked-list</id>
    <content type="html"><![CDATA[<p>A lot of people are familiar with the problem of detecting a loop in a linked list. The problem goes as follows: “Given a linked list, what is the algorithm to determine if it has any cycles (loops)?”</p>

<p>The algorithm is pretty straightforward:</p>

<ol>
<li>We start at the beginning of the linked list with two pointers.</li>
<li>The first pointer is incremented through each node of the list. The second pointer moves twice as fast, and skips every other node.</li>
<li>If the linked list contains a loop, these two pointers will eventually meet at the same node, thus indicating that the linked list contains a loop.</li>
</ol>


<p>The algorithm is straightforward and it is relatively easy to create a mental model and get an intuitive sense of why it works.</p>

<p>Now, a slight twist to the same question asks: “Given a circular linked list, what is the algorithm to find the first node of the loop.”</p>

<!-- more -->


<p>For instance, in the circular list <code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C</code>, the first node of the loop is node C. The first part of the algorithm is identical to the algorithm for finding if there is a loop (above). Once a loop has been found, the following additional steps will give us the starting node of the loop:</p>

<ol>
<li>Once a loop as been detected (step-3 above), move one of the pointers to the beginning (head) of the linked list. The second pointer remains where it was at the end of step-3.</li>
<li>Increment both pointers one node at a time. The node at which the two pointers meet will be the starting node of the loop!</li>
</ol>


<p>This algorithm isn’t too difficult compared to the algorithm for detecting a loop. However, the mental model seems a bit trickier. Why and how does it always find the start of the loop?</p>

<h3>How does the Algorithm work? An intuitive explanation:</h3>

<p>Here’s some explanation which would hopefully help you intuitively understand why the algorithm works, without going into a lot of mathematical detail.</p>

<h4>First, meeting point of two pointers in a loop</h4>

<p>Consider two pointers: a slow pointer <code>S</code> that increments by one node at each step, and a fast pointer <code>F</code> that increments by two nodes at each step (i.e. it is twice as fast as <code>S</code>). Both pointers start at the same time from the beginning of an n-node loop. In the time <code>S</code> covers n nodes. <code>F</code> will have covered <code>2n</code> nodes and they will both meet at the start of the loop.</p>

<p>Now, let us say that the slow pointer <code>S</code> starts at the beginning of the loop, and the fast pointer <code>F</code> starts at node k (where k &lt; n) of the loop. As these two pointers move along the loop, they will meet at node (n-x).</p>

<p>What we really need to do is figure out x, as it will give us the node at which the two pointers meet inside the loop.</p>

<ol>
<li>When <code>S</code> takes <code>n/2</code> steps, it will be at node <code>n/2</code>. During the same time, <code>F</code> will have taken <code>2(n/2) = n</code> steps, and it will be at node <code>(k+n)</code>. Since the we are inside a loop, <code>F</code> will be effectively back at node <code>k</code>.</li>
<li>In order for the two pointers to meet at node <code>(n-x)</code>, <code>S</code> needs to take a further <code>(n-x-n/2)=(n/2-x)</code> steps and it will end up at node <code>n-x</code>. During the same time, <code>F</code> will have taken 2*(n/2-x)=(n-2x) steps and will be at node <code>k+(n-2x)</code>. Given our assumption that both S and <code>F</code> meet at the same node:</li>
</ol>


<pre><code>            n-x = k+n-2x
        =&gt;    x = k
</code></pre>

<p>This means that if S starts from the start of the loop, and F starts k nodes into the loop, both of them will meet at node (n-k), i.e k nodes from the end of the loop. This is a key insight.</p>

<h4>Circular Linked List</h4>

<p>Now, coming back to the linked list that contains a loop. Suppose the start of the loop is <code>m</code> (e.g. <code>m</code>=3) nodes from the start of the linked list. Both <code>S</code> and <code>F</code> start at the beginning of the linked list [Figure-1].</p>

<p><img class="center" src="/images/circular-loop-figure-1.jpg" title="Figure-1" ></p>

<p style="text-align:center;"> <em>Figure-1: Circular linked list with S and F pointers at the start</em></p>

<p>By the time <code>S</code> gets to node <code>m</code> (i.e. start of loop), <code>F</code> will be at node <code>2m</code> [Figure-2]. This means that <code>S</code> will be at the start of the loop and <code>F</code> will be <code>m</code> nodes <em>into the loop</em>.</p>

<p><img class="center" src="/images/circular-loop-figure-2.jpg" title="Figure-2" ></p>

<p style="text-align:center;"> <em>Figure-2: Circular linked list, with S at the start of loop and F m nodes into the loop</em></p>

<p>Based on the discussion above, we already know that if <code>S</code> begins from the start of the loop and <code>F</code> starts from node <code>m</code>, they will meet <code>m</code> nodes from the end of the loop (i.e. the orange-node in [Figure-3]).</p>

<p><img class="center" src="/images/circular-loop-figure-3.jpg" title="Figure-3" ></p>

<p style="text-align:center;"> <em>Figure-3: Both F and S meet m nodes from the end of the loop</em></p>

<p>At this point, keep the pointer <code>F</code> at the orange-node where the two pointers met (i.e. <code>m</code>-nodes from the start of the loop), and move the pointer <code>S</code> to the beginning of the linked list [Figure-4]. Now, if we increment both <code>S</code> and <code>F</code> <em>one node at a time</em>, it is obvious that they will meet at &lsquo;Node-m&rsquo; (red-node) of the list, which is the start of the loop.</p>

<p><img class="center" src="/images/circular-loop-figure-4.jpg" title="Figure-4" ></p>

<p style="text-align:center;"> <em>Figure-4: S at the start of linked list, F at the point they met. Both increment one at a time from here-on</em></p>

<p>For the curious, here’s the Java code snippets for detecting a loop in a linked list and finding the starting node. The complete source code for my linked list project is at my Github page (<a href="https://github.com/umairsd/LinkedList-Java">https://github.com/umairsd/LinkedList-Java</a>):</p>

<pre><code class="java">/**
 * Checks if the given linked list is a circular linked list (i.e. it
 * contains a loop). This means a list in which a node's next pointer points
 * to an earlier node, so as to make a loop in the linked list. For
 * instance:
 *          A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; C
 *
 * @param linkedList
 *            the linked list to be tested
 * @return true if there is a loop, false if there isn't
 */
public static boolean hasLoop(LinkedList linkedList) {
    if (linkedList == null || linkedList.getHead() == null) {
        return false;
    }

    IntegerNode slow = linkedList.getHead();
    IntegerNode fast = linkedList.getHead();

    while (true) {
        slow = slow.getNext();

        if (fast.getNext() != null) {
            fast = fast.getNext().getNext();
        } else {
            return false;
        }

        if (slow == null || fast == null) {
            return false;
        }

        if (slow == fast) {
            return true;
        }
    }
}
</code></pre>

<pre><code class="java">/**
 * Returns the node at the start of a loop in the given circular linked
 * list. A circular list is one in which a node's next pointer points
 * to an earlier node, so as to make a loop in the linked list. For
 * instance:
 *
 * input: A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; C [the same C as earlier]
 * output: C
 *
 * (CCI_0205)
 *
 * @param linkedList
 *            list to be tested
 * @return the node at the start of the loop if there is a loop, null
 * otherwise
 */
public static IntegerNode findLoopStart(LinkedList linkedList) {
    if (linkedList == null || linkedList.getHead() == null) {
        return null;
    }

    IntegerNode loopStartNode = null;
    IntegerNode slow = linkedList.getHead();
    IntegerNode fast = linkedList.getHead();

    while (slow != null &amp;&amp; fast != null) {
        slow = slow.getNext();
        if (fast.getNext() == null) {
            loopStartNode = null;
            break;
        }
        fast = fast.getNext().getNext();

        // If slow and fast point to the same node, it means that the
        // linkedList contains a loop.
        if (slow == fast) {

            slow = linkedList.getHead();

            while (slow != fast) {
                // Keep incrementing the two pointers until they both
                // meet again. When this happens, both the pointers will
                // point to the beginning of the loop
                slow = slow.getNext(); // Can't be null, as we have a loop
                fast = fast.getNext(); // Can't be null, as we have a loop
            }

            loopStartNode = slow;
            break;
        }
    }

    return loopStartNode;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
