<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Haskell | Umair's blog]]></title>
  <link href="http://umairsd.github.io/blog/categories/haskell/atom.xml" rel="self"/>
  <link href="http://umairsd.github.io/"/>
  <updated>2015-05-17T07:49:36-07:00</updated>
  <id>http://umairsd.github.io/</id>
  <author>
    <name><![CDATA[Umair Saeed]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Index Based List Operations Using Folds in Haskell]]></title>
    <link href="http://umairsd.github.io/blog/2015/05/16/index-based-list-operations-using-folds-in-haskell/"/>
    <updated>2015-05-16T08:53:31-07:00</updated>
    <id>http://umairsd.github.io/blog/2015/05/16/index-based-list-operations-using-folds-in-haskell</id>
    <content type="html"><![CDATA[<p>Whenever working with lists in Haskell, occasionally there&rsquo;s a need to perform index based operations, such as adding an element at a particular index. Going by my experience, using <code>foldl</code> or <code>foldr</code> is not the first idea that comes to mind for index based operations. However, there is a general pattern that can be applied when using folds for index-based list operations. For example, consider the case where we need to add an element at a particular index:</p>

<!-- more -->


<pre><code class="haskell">-- inserting at an index, using foldr
insertAt :: a -&gt; [a] -&gt; Int -&gt; [a]
insertAt x ys n = foldr insertHelper [] $ zip [0..] ys
    where 
        insertHelper (i,y) acc = if i == n
            then x : y : acc
            else y : acc
</code></pre>

<p>The basic idea is simple: We simply zip <code>[0..]</code> with the input list (<code>ys</code>) to get at a list of tuples. The first element of each tuple is the index of the element in the list <code>ys</code> (input list). This allows us to perform index based tests in the helper function, as shown in <code>insertHelper</code> above.</p>

<p>Both left and right folds can be used for index based list operations. Here&rsquo;s the same example using <code>foldl</code>.</p>

<pre><code class="haskell">-- inserting at an index, using foldl
insertAtL :: a -&gt; [a] -&gt; Int -&gt; [a]
insertAtL x ys n = foldl insertLHelper [] $ zip [0..] ys
    where 
        insertLHelper acc (i,y) = if i == n
            then acc ++ [x] ++ [y]
            else acc ++ [y]
</code></pre>

<p>Both left and right fold produce the same result. Adding an element to the head of the list (via <code>:</code>) is more efficient than concatenating lists (via <code>++</code>), so generally I prefer using the 1st version, i.e. one that uses <code>foldr</code></p>

<p><a href="https://gist.github.com/umairsd/cdcb397941762fe02d05">Here&rsquo;s a gist</a> with examples of  <code>insertAt</code>, <code>updateAt</code>, and <code>deleteAt</code> functions, all implemented using folds.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sublime Text &amp; Haskell]]></title>
    <link href="http://umairsd.github.io/blog/2015/05/02/sublime-text-and-haskell/"/>
    <updated>2015-05-02T16:07:28-07:00</updated>
    <id>http://umairsd.github.io/blog/2015/05/02/sublime-text-and-haskell</id>
    <content type="html"><![CDATA[<p>There are several excellent posts about setting up the Haskell development environment. One of the best ones is Tony Lawrence&rsquo;s <a href="http://tonylawrence.com/blog/2014/01/01/configuring-your-haskell-environment/" title="Configuring Your Haskell Environment">Configuring Your Haskell Environment</a>. I encourage you to take a look at his post first.</p>

<p>Tony&rsquo;s post is more than a year old though, and it looks like a couple of things have changed since he wrote his post, especially with the latest version of Haskell and <a href="https://github.com/SublimeHaskell/SublimeHaskell" title="SublimeHaskell">SublimeHaskell</a>. I wasted a good chunk of time trying to get around those problems, so now writing this post in case others run into similar issues when setting up the SublimeHaskell plugin.</p>

<!-- more -->


<p>Here&rsquo;s a summary of the steps to setup the Haskell dev environment (from <a href="https://github.com/SublimeHaskell/SublimeHaskell" title="SublimeHaskell">Tony&rsquo;s blog</a>).</p>

<ul>
<li>Install the Haskell platform.</li>
<li>Issue <code>cabal update</code> to update the list of available packages for Haskell.</li>
<li>Install the requisite packages by issuing <code>cabal install aeson haskell-src-exts haddock hdevtools</code>.</li>
<li>Install Sublime Text 3.</li>
<li>Install Package Control for Sublime Text 3.</li>
<li>Install SublimeHaskell via Package Control.</li>
</ul>


<p>This last step doesn&rsquo;t work seamlessly. When I installed SublimeHaskell, I ran into the following error message in Sublime Text:</p>

<pre><code>SublimeHaskell: Failed to compile ModuleInspector

/Users/umair/Library/Application Support/Sublime Text 3/Packages/SublimeHaskell/ModuleInspector.hs:141:12:
    Not in scope: data constructor ‘H.PNeg’
    Perhaps you meant ‘H.PRec’ (imported from Language.Haskell.Exts)
</code></pre>

<p>The problem is described in more detail in <a href="https://github.com/SublimeHaskell/SublimeHaskell/issues/182" title="SublimeHaskell issue # 182">issue #182</a> on <a href="https://github.com/SublimeHaskell/SublimeHaskell" title="SublimeHaskell">SublimeHaskell&rsquo;s GitHub page</a>. The summary is that the master branch of SublimeHaskell is too slow to accomodate the removal of <code>PNeg</code> from <code>haskell-src-exts</code>. The solution is to use the <code>hsdev</code> branch of SublimeHaskell. This is done as follows (recommended by <a href="https://github.com/MoreAxes" title="GitHub user MoreAxes">MoreAxes</a> on comment thread for <a href="https://github.com/SublimeHaskell/SublimeHaskell/issues/182" title="SublimeHaskell issue # 182">issue #182</a>):</p>

<ul>
<li>In Sublime Text, launch Package Control (<code>cmd-shift-p</code>), and use the &lsquo;Add Repository&rsquo; command to add <code>https://github.com/SublimeHaskell/SublimeHaskell/tree/hsdev</code>.</li>
<li>Install SublimeHaskell with Package Control normally. Package Control looks in user-defined repositories first, so it is able to get SublimeHaskell from the <code>hsdev</code> branch.</li>
<li>Restart Sublime Text.</li>
</ul>


<p>You can now enter and build Haskell code from Sublime Text. To verify your setup, enter the following code in Sublime Text, and then hit <code>cmd-B</code></p>

<pre><code class="haskell">main :: IO()
main = do
    print "Hello World"
</code></pre>

<p>You will see the following printed:</p>

<pre><code>"Hello World"
[Finished in 0.2s]
</code></pre>

<p>Here&rsquo;s a screenshot of my test file, with the output of the program:</p>

<p><img class="center" src="/images/sublime-text-haskell-test.png"></p>
]]></content>
  </entry>
  
</feed>
