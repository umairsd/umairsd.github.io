<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Haskell | Umair's blog]]></title>
  <link href="http://umairsd.github.io/blog/categories/haskell/atom.xml" rel="self"/>
  <link href="http://umairsd.github.io/"/>
  <updated>2015-11-17T07:07:53-08:00</updated>
  <id>http://umairsd.github.io/</id>
  <author>
    <name><![CDATA[Umair Saeed]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Maybe as an Applicative Functor]]></title>
    <link href="http://umairsd.github.io/blog/2015/08/21/maybe-as-an-applicative-functor/"/>
    <updated>2015-08-21T09:53:20-07:00</updated>
    <id>http://umairsd.github.io/blog/2015/08/21/maybe-as-an-applicative-functor</id>
    <content type="html"><![CDATA[<p><code>Maybe</code> type is made an instance of the <code>Applicative</code> type class as follows (<a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors" title="Learn You a Haskell for Great Good, Applicative Functors">link</a>):</p>

<pre><code class="haskell">instance Applicative Maybe where
    pure = Just
    Nothing &lt;*&gt; _ = Nothing
    (Just f) &lt;*&gt; something = fmap f something
</code></pre>

<p>It took me a several attempts before I could parse this definition. I was particularly puzzled by the line <code>(Just f) &lt;*&gt; something = fmap f something</code>. To help me understand this better, I decided to build this definition back up from the very basics.</p>

<!-- more -->


<p>First, let&rsquo;s look at the <code>Functor</code> type class definition:</p>

<pre><code class="haskell">class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

<p>This means that for a given functor type <code>f</code> (i.e. type that is an instance of the <code>Functor</code> type class), <code>fmap</code> takes a function from <code>a -&gt; b</code> and a functor (box) that contains <code>a</code> and returns a functor (box) that contains <code>b</code>. An intuitive way to think about this is that <code>fmap</code> opens the box containing <code>a</code> and applies the function <code>a -&gt; b</code> to it, which results in <code>b</code>.</p>

<p>Now let&rsquo;s see how <code>Maybe</code> is an instance of the <code>Functor</code> type class:</p>

<pre><code class="haskell">instance Functor Maybe where
    fmap func Nothing  = Nothing
    fmap func (Just x) = Just (func x)
</code></pre>

<ul>
<li>Line 2: Applying a function to <code>Nothing</code> results in <code>Nothing</code>.</li>
<li>Line 3: From the definition of the <code>Functor</code> type, we know that the type of <code>func</code> is <code>a -&gt; b</code> and <code>Just x</code> corresponds to <code>f a</code>. Applying the function to <code>x</code> inside the box results in a value of type <code>b</code> in the functor box.</li>
</ul>


<p>Now, let&rsquo;s look at the definition of the <code>Applicative</code> type class:</p>

<pre><code class="haskell">class (Functor f) =&gt; Applicative f where  -- 1
    pure :: a -&gt; f a                      -- 2
    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b     -- 3
</code></pre>

<p>For a type <code>f</code> that is an instance of the <code>Applicative</code> type class, here is what each line means:</p>

<ol>
<li><code>f</code> must also be a functor (i.e. be an instance of the <code>Functor</code> type class).</li>
<li>The <code>pure</code> function takes an arbitrary type <code>a</code> and brings it into the functor. i.e. <code>pure</code> puts <code>a</code> in a box of type <code>f</code>.</li>
<li><code>&lt;*&gt;</code> takes a functor (box) of type <code>f</code> that contains a function of type <code>a -&gt; b</code>, and a functor (box) of type <code>f</code> that contains type <code>a</code>. It results in a functor (box) of type <code>f</code> that contains <code>b</code>.</li>
</ol>


<p>With the preamble out of the way, let&rsquo;s make <code>Maybe</code>  an instance of the <code>Applicative</code> type class. To do that, I need to implement the <code>pure</code> and <code>&lt;*&gt;</code> methods for the <code>Maybe</code> type. Below is a line-by-line implementation:</p>

<pre><code class="haskell">instance Applicative Maybe where
    pure x = Just x
</code></pre>

<p>For the <code>Maybe</code> type, <code>pure</code> simply wraps an arbitrary type in <code>Just</code>, thus making it a <code>Maybe</code> value. E.g. writing <code>pure 4 :: Maybe Int</code> in GHCi results in <code>Just 4</code>.</p>

<pre><code class="haskell">    (&lt;*&gt;) Nothing _ = Nothing
</code></pre>

<p>Here, <code>Nothing</code> maps to <code>f (a -&gt; b)</code> from the <code>Applicative</code> class definition. We cannot extract a function out of <code>Nothing</code>, so the result will be <code>Nothing</code> regardless of the second argument.</p>

<pre><code class="haskell">    (&lt;*&gt;) (Just func) Nothing = Nothing
</code></pre>

<p>In the line above, <code>(Just func)</code> maps to <code>f (a -&gt; b)</code>, and <code>Nothing</code> maps to <code>f a</code> from the class definition. <code>&lt;*&gt;</code> extracts <code>func</code> out of <code>Just func</code>, and applies it to <code>Nothing</code>. Applying a function to <code>Nothing</code> results in <code>Nothing</code> (or, using the box analogy, applying a function to an empty box results in an empty box)</p>

<pre><code class="haskell">    (&lt;*&gt;) (Just func) (Just x) = Just (func x) 
</code></pre>

<p><code>(Just func)</code> maps to <code>f (a -&gt; b)</code>, and <code>Just x</code> maps to <code>f a</code> from the <code>Applicative</code> class definition. <code>&lt;*&gt;</code> extracts the function from <code>Just func</code>, and applies it to <code>x</code> inside the <code>Just x</code> box. The result is <code>Just (func x)</code>.</p>

<p>Now, let&rsquo;s put the definition of <code>&lt;*&gt;</code> for <code>Maybe</code> type next to the definition of the <code>fmap</code> function:</p>

<pre><code class="haskell">    (&lt;*&gt;) (Just func) Nothing  = Nothing
    (&lt;*&gt;) (Just func) (Just x) = Just (func x) 

    fmap func Nothing  = Nothing
    fmap func (Just x) = Just (func x)
</code></pre>

<p>This makes it obvious that in the definition of <code>&lt;*&gt;</code>, once we extract <code>func</code> out of <code>Just func</code>, we simply map that function over the second argument of <code>&lt;*&gt;</code> (which will be of <code>Maybe</code> type as well). This means that the <code>&lt;*&gt;</code> implementation for <code>Maybe</code> can be re-written as:</p>

<pre><code class="haskell">    &lt;*&gt; (Just func) something = fmap func something
</code></pre>

<p>This is exactly how the <code>&lt;*&gt;</code> function is implemented at the beginning of this blog post.</p>

<p>Finally, <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" title="Functors, Applicatives, And Monads in Pictures">Functors, Applicatives, And Monads In Pictures</a> by <a href="https://twitter.com/_egonschiele" title="Aditya Bhargava's Twitter Page">Aditya Bhargava</a> is one of the best posts I&rsquo;ve read on functors &amp; applicatives. I highly recommend it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pascal's Triangle]]></title>
    <link href="http://umairsd.github.io/blog/2015/07/08/pascals-triangle/"/>
    <updated>2015-07-08T06:51:27-07:00</updated>
    <id>http://umairsd.github.io/blog/2015/07/08/pascals-triangle</id>
    <content type="html"><![CDATA[<p>One of the exercises in <a href="https://mitpress.mit.edu/sicp/">Structure and Implementation of Computer Programs</a> deals with generating elements of the <a href="https://en.wikipedia.org/wiki/Pascal's_triangle">Pascal&rsquo;s Triangle</a>. The following pattern of numbers is called <em>Pascal&rsquo;s Triangle</em></p>

<pre><code>
    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1
...
</code></pre>

<p>The numbers at the edge of the triangle are 1, and each number inside is the sum of two numbers above it. The exercise asks us to <em>find the elements of Pascal&rsquo;s triangle by means of a recursive process</em>.</p>

<!-- More -->


<p>I find it helpful to <em>de-skew</em> the triangle so that the rows and columns line up visually. Here&rsquo;s the modified triangle:</p>

<pre><code>
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
...
</code></pre>

<p>I decided to write the solution in Haskell, and here it is:</p>

<pre><code class="haskell">-- A: Function that finds the element of Pascal's Triangle for a given row &amp; column
pascal :: Int -&gt; Int -&gt; Int
pascal 0 _ = 1
pascal _ 0 = 1
pascal row col
    | row == col = 1
    | col &gt; row  = error "Column can't be greater than row"
    | otherwise  = (pascal (row-1) (col-1)) + (pascal (row-1) col)
</code></pre>

<p>This code is great for generating the element at a given row and column (e.g. <code>pascal 3 2</code> produces <code>3</code>), but not so great if we wanted to generate the entire triangle up to <code>n</code> rows, as we would recursively generate the elements at row <code>n-1</code> multiple times.</p>

<p>In order to generate the entire triangle, it is better to do it via an iterative process as follows: generate the first row, and from that generate the second row, and so on. I other words, we are generating the next row of the triangle, by adding each pair in the current row. My solution is as follows:</p>

<pre><code class="haskell">-- Takes an array of integers, and adds pairs of numbers to create a new 
-- array. For example, [1,2,3,4] changes to [(1+2), (2+3), (3+4)], resulting
-- in [3,5,7]
sumOfPairs :: [Integer] -&gt; [Integer]
sumOfPairs [] = []
sumOfPairs (x:[]) = []
sumOfPairs (x:y:ys) = (x+y) : sumOfPairs (y:ys)


-- Given a row of Pascal's triangle, returns the next row
next :: [Integer] -&gt; [Integer]
next xs = 1 :  (sumOfPairs xs) ++ [1]


-- Generates the Pascal's triangle. This function generates an
-- infinite triangle, so its usage needs to be coupled with the 
-- take command. For example: take 5 pascalTriangle
pascalTriangle :: [[Integer]]
pascalTriangle = pascalHelper [1]
    where pascalHelper xs = xs : pascalHelper (next xs)
</code></pre>

<p>Here are a couple of examples of generating the triangle:</p>

<pre><code class="haskell">*Main&gt; take 4 pascalTriangle 
[[1],[1,1],[1,2,1],[1,3,3,1]]

-- Using mapM_ with print to 'pretty-print' the triangle
*Main&gt; mapM_ print $ take 8 pascalTriangle
[1]
[1,1]
[1,2,1]
[1,3,3,1]
[1,4,6,4,1]
[1,5,10,10,5,1]
[1,6,15,20,15,6,1]
[1,7,21,35,35,21,7,1]
</code></pre>

<p>The function <code>pascalTriangle</code> can be made more concise by using the built-in <code>iterate</code> instead of my <code>pascalHelper</code>:</p>

<pre><code class="haskell">pascalTriangle :: [[Integer]]
pascalTriangle = iterate next [1]
</code></pre>

<p>By this point, I was reasonably satisfied with the code. However, being relatively new to Haskell, I decided to explore and see if there were other (and possibly better and more idiomatic) ways to solve this problem. My favorite was by <a href="http://neilmitchell.blogspot.com/2012/01/pascals-triangle-in-haskell.html">Neil Mitchell</a>, who solved the problem in two lines! I encourage you to go read <a href="http://neilmitchell.blogspot.com/2012/01/pascals-triangle-in-haskell.html">Neil&rsquo;s entire post</a>. Here&rsquo;s the two-line version of Haskell&rsquo;s triangle:</p>

<pre><code class="haskell">-- By: Neil Mitchell 
-- (http://neilmitchell.blogspot.com/2012/01/pascals-triangle-in-haskell.html)

next xs = zipWith (+) ([0] ++ xs) (xs ++ [0])
pascal = iterate next [1]
</code></pre>

<p>In my view, this code is very elegant and beautiful and does a great job of highlighting the power of Haskell.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Index Based List Operations Using Folds in Haskell]]></title>
    <link href="http://umairsd.github.io/blog/2015/05/16/index-based-list-operations-using-folds-in-haskell/"/>
    <updated>2015-05-16T08:53:31-07:00</updated>
    <id>http://umairsd.github.io/blog/2015/05/16/index-based-list-operations-using-folds-in-haskell</id>
    <content type="html"><![CDATA[<p>When working with lists in Haskell, occasionally there&rsquo;s a need to perform index based operations, such as adding an element at a particular index. Going by my experience, using <code>foldl</code> or <code>foldr</code> is not the first idea that comes to mind when indices are involved. However, there is a general pattern that can be applied when using folds for index-based list operations. For example, consider the case where we need to add an element at a particular index:</p>

<!-- more -->


<pre><code class="haskell">-- inserting at an index, using foldr
insertAt :: a -&gt; [a] -&gt; Int -&gt; [a]
insertAt x ys n = foldr insertHelper [] $ zip [0..] ys
    where 
        insertHelper (i,y) acc = if i == n
            then x : y : acc
            else y : acc
</code></pre>

<p>The basic idea is simple: We simply zip <code>[0..]</code> with the input list (<code>ys</code>) to get a list of tuples. The first element of each tuple is the index of the element in the list <code>ys</code> (input list). This allows us to perform index based tests in the helper function, as shown in <code>insertHelper</code> above.</p>

<p>Both left and right folds can be used for index based list operations. Here&rsquo;s the same example using <code>foldl</code>.</p>

<pre><code class="haskell">-- inserting at an index, using foldl
insertAtL :: a -&gt; [a] -&gt; Int -&gt; [a]
insertAtL x ys n = foldl insertLHelper [] $ zip [0..] ys
    where 
        insertLHelper acc (i,y) = if i == n
            then acc ++ [x] ++ [y]
            else acc ++ [y]
</code></pre>

<p>Both left and right fold produce the same result. Adding an element to the head of the list (via <code>:</code>) is more efficient than concatenating lists (via <code>++</code>), so generally I prefer using the 1st version, i.e. one that uses <code>foldr</code></p>

<p><a href="https://gist.github.com/umairsd/cdcb397941762fe02d05">Here&rsquo;s a gist</a> with examples of  <code>insertAt</code>, <code>updateAt</code>, and <code>deleteAt</code> functions, all implemented using folds.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sublime Text &amp; Haskell]]></title>
    <link href="http://umairsd.github.io/blog/2015/05/02/sublime-text-and-haskell/"/>
    <updated>2015-05-02T16:07:28-07:00</updated>
    <id>http://umairsd.github.io/blog/2015/05/02/sublime-text-and-haskell</id>
    <content type="html"><![CDATA[<p>There are several excellent posts about setting up the Haskell development environment. One of the best ones is Tony Lawrence&rsquo;s <a href="http://tonylawrence.com/blog/2014/01/01/configuring-your-haskell-environment/" title="Configuring Your Haskell Environment">Configuring Your Haskell Environment</a>. I encourage you to take a look at his post first.</p>

<p>Tony&rsquo;s post is more than a year old though, and it looks like a couple of things have changed since he wrote his post, especially with the latest version of Haskell and <a href="https://github.com/SublimeHaskell/SublimeHaskell" title="SublimeHaskell">SublimeHaskell</a>. I wasted a good chunk of time trying to get around those problems, so now writing this post in case others run into similar issues when setting up the SublimeHaskell plugin.</p>

<!-- more -->


<p>Here&rsquo;s a summary of the steps to setup the Haskell dev environment (from <a href="https://github.com/SublimeHaskell/SublimeHaskell" title="SublimeHaskell">Tony&rsquo;s blog</a>).</p>

<ul>
<li>Install the Haskell platform.</li>
<li>Issue <code>cabal update</code> to update the list of available packages for Haskell.</li>
<li>Install the requisite packages by issuing <code>cabal install aeson haskell-src-exts haddock hdevtools</code>.</li>
<li>Install Sublime Text 3.</li>
<li>Install Package Control for Sublime Text 3.</li>
<li>Install SublimeHaskell via Package Control.</li>
</ul>


<p>This last step doesn&rsquo;t work seamlessly. When I installed SublimeHaskell, I ran into the following error message in Sublime Text:</p>

<pre><code>SublimeHaskell: Failed to compile ModuleInspector

/Users/umair/Library/Application Support/Sublime Text 3/Packages/SublimeHaskell/ModuleInspector.hs:141:12:
    Not in scope: data constructor ‘H.PNeg’
    Perhaps you meant ‘H.PRec’ (imported from Language.Haskell.Exts)
</code></pre>

<p>The problem is described in more detail in <a href="https://github.com/SublimeHaskell/SublimeHaskell/issues/182" title="SublimeHaskell issue # 182">issue #182</a> on <a href="https://github.com/SublimeHaskell/SublimeHaskell" title="SublimeHaskell">SublimeHaskell&rsquo;s GitHub page</a>. The summary is that the master branch of SublimeHaskell is too slow to accomodate the removal of <code>PNeg</code> from <code>haskell-src-exts</code>. The solution is to use the <code>hsdev</code> branch of SublimeHaskell. This is done as follows (recommended by <a href="https://github.com/MoreAxes" title="GitHub user MoreAxes">MoreAxes</a> on comment thread for <a href="https://github.com/SublimeHaskell/SublimeHaskell/issues/182" title="SublimeHaskell issue # 182">issue #182</a>):</p>

<ul>
<li>In Sublime Text, launch Package Control (<code>cmd-shift-p</code>), and use the &lsquo;Add Repository&rsquo; command to add <code>https://github.com/SublimeHaskell/SublimeHaskell/tree/hsdev</code>.</li>
<li>Install SublimeHaskell with Package Control normally. Package Control looks in user-defined repositories first, so it is able to get SublimeHaskell from the <code>hsdev</code> branch.</li>
<li>Restart Sublime Text.</li>
</ul>


<p>You can now enter and build Haskell code from Sublime Text. To verify your setup, enter the following code in Sublime Text, and then hit <code>cmd-B</code></p>

<pre><code class="haskell">main :: IO()
main = do
    print "Hello World"
</code></pre>

<p>You will see the following printed:</p>

<pre><code>"Hello World"
[Finished in 0.2s]
</code></pre>

<p>Here&rsquo;s a screenshot of my test file, with the output of the program:</p>

<p><img class="center" src="/images/sublime-text-haskell-test.png"></p>
]]></content>
  </entry>
  
</feed>
