<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: haskell | Umair's blog]]></title>
  <link href="http://umairsd.github.io/blog/categories/haskell/atom.xml" rel="self"/>
  <link href="http://umairsd.github.io/"/>
  <updated>2016-01-07T05:47:52-08:00</updated>
  <id>http://umairsd.github.io/</id>
  <author>
    <name><![CDATA[Umair Saeed]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Applicative Laws for ((->) r) Type]]></title>
    <link href="http://umairsd.github.io/blog/2016/01/07/applicative-laws-for-function-type/"/>
    <updated>2016-01-07T05:00:29-08:00</updated>
    <id>http://umairsd.github.io/blog/2016/01/07/applicative-laws-for-function-type</id>
    <content type="html"><![CDATA[<p>This is Part-3 of my series on verifying Applicative laws for various Haskell types. Here are Part-1 <a href="http://umairsaeed.com/blog/2016/01/05/applicative-laws-for-maybe-type/" title="Applicative Laws for Maybe Type">Applicative Laws for Maybe Type</a> and Part-2 <a href="http://umairsaeed.com/blog/2016/01/06/applicative-laws-for-list-type/" title="Applicative Laws for List Type">Applicative Laws for [] Type</a></p>

<hr />

<p>Haskell&rsquo;s function type <code>((-&gt;) r)</code> is an Applicative functor. Similar to the previous two posts in this series, in this post I will verify that the applicative laws hold for the <code>((-&gt;) r)</code> type.</p>

<p>For reference, <code>((-&gt;) r)</code> is made an instance of the <code>Applicative</code> class as:</p>

<pre><code class="haskell">instance Applicative ((-&gt;) r) where
    pure x = (\_ -&gt; x)
    -- pure can also be written as:
    -- pure x = const x

    -- (&lt;*&gt;) :: f (a-&gt;b) -&gt; f a -&gt; f b
    -- (&lt;*&gt;) :: ((-&gt;) r (a-&gt;b)) -&gt; ((-&gt;) r a) -&gt; ((-&gt;) r b)
    -- (&lt;*&gt;) :: (r -&gt; (a-&gt;b)) -&gt; (r -&gt; a) -&gt; (r -&gt; b)
    -- the entire lambda has type r -&gt; b, which implies x :: r
    (&lt;*&gt;) f g = (\x -&gt; f x (g x))
</code></pre>

<!-- more -->


<p>For review, here are the applicative laws:</p>

<ul>
<li><p>Identity: <code>pure id &lt;*&gt; v = v</code></p></li>
<li><p>Homomorphism: <code>pure f &lt;*&gt; pure x = pure (f x)</code></p></li>
<li><p>Interchange: <code>u &lt;*&gt; pure y = pure ($y) &lt;*&gt; u</code></p></li>
<li><p>Composition: <code>pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code></p></li>
</ul>


<h3>Identity</h3>

<p>We need to prove that the following holds for the <code>((-&gt;) r)</code> type:</p>

<pre><code class="haskell">pure id &lt;*&gt; v = v
</code></pre>

<p>Beginning from LHS:</p>

<pre><code class="haskell">pure (id) &lt;*&gt; v
-- using definition of pure
const id &lt;*&gt; v

-- applying definition of &lt;*&gt;
(\x -&gt; const id x (v x))

-- applying const
(\x -&gt; id (v x))

-- applying id
(\x -&gt; v x)

v -- RHS
</code></pre>

<h3>Homomorphism</h3>

<p>The law&rsquo;s statement is:</p>

<pre><code class="haskell">pure f &lt;*&gt; pure x = pure (f x)
</code></pre>

<p>Here&rsquo;s the proof:</p>

<pre><code class="haskell">pure f &lt;*&gt; pure x

-- applying definition of pure
const f &lt;*&gt; const x

-- applying definition of &lt;*&gt;
(\y -&gt; const f y (const x y))

-- applying const
(\y -&gt; f (x))

-- As y is unused, replace with _
(\_ -&gt; f x)

-- un-applying definition of pure
pure (f x) -- RHS
</code></pre>

<h3>Interchange</h3>

<p>The law&rsquo;s statement is:</p>

<pre><code class="haskell">u &lt;*&gt; pure y = pure ($y) &lt;*&gt; u
</code></pre>

<p>Starting from the LHS:</p>

<pre><code class="haskell">u &lt;*&gt; pure y

-- applying definition of pure
u &lt;*&gt; const y

-- applying definition of &lt;*&gt;
\x -&gt; u x (const y x)

-- applying const
\x -&gt; u x (y)

\x -&gt; u x y
</code></pre>

<p>Now, starting from the RHS:</p>

<pre><code class="haskell">pure ($y) &lt;*&gt; u

-- applying definition of pure
const ($y) &lt;*&gt; u

-- applying definition of &lt;*&gt;
\x -&gt; const ($y) x (u x)

-- applying const
\x -&gt; ($y) (u x)

-- applying definition of function application operator ($)
\x -&gt; (u x) $ y

\x -&gt; u x y
</code></pre>

<p>As both the left and right sides reduce to the same statement, the interchange law is proved for the <code>((-&gt;) r)</code> type</p>

<h3>Composition</h3>

<p>The law&rsquo;s statement is:</p>

<pre><code class="haskell">pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)
</code></pre>

<p>Starting from the <em>right</em> side of the equation:</p>

<pre><code class="haskell">u &lt;*&gt; (v &lt;*&gt; w)

-- applying definition of &lt;*&gt;
u &lt;*&gt; ( \y -&gt; v y (w y) )

-- applying definition of &lt;*&gt;
\x -&gt; u x ( (\y -&gt; v y (w y)) x )

-- Apply the lambda ( (\y -&gt; v y (w y)) to its 
-- argument x, which results in:
\x -&gt; u x ( v x (w x)) -- (A)
</code></pre>

<p>In the same manner, let&rsquo;s consider the <em>left</em> side of the equation:</p>

<pre><code class="haskell">pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w

-- applying definition of pure
const (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w

-- applying definition of &lt;*&gt; to the 1st two terms
(\f -&gt; const (.) f (u f)) &lt;*&gt; v &lt;*&gt; w

-- applying const
(\f -&gt; (.) (u f)) &lt;*&gt; v &lt;*&gt; w

-- applying definition of &lt;*&gt; to the 1st two terms
(\g -&gt; (\f -&gt; (.) (u f)) g (v g)) &lt;*&gt; w

-- applying definition of &lt;*&gt;
\x -&gt; (\g -&gt; (\f -&gt; (.) (u f)) g (v g)) x (w x)

-- Expanding the lambda (\g -&gt; ...) by applying to x
\x -&gt; ((\f -&gt; (.) (u f)) x (v x)) (w x)

-- Expanding the inner lambda (\f -&gt; ...) by applying to x
\x -&gt; (( (.) (u x)) (v x))  (w x)

-- Using definition of function composition (.)
\x -&gt; ((u x) . (v x)) (w x) 

-- Using definition of (.), i.e. f.g x = f (g x)
\x -&gt; u x ( v x (w x) ) -- (B)
</code></pre>

<p>(A) &amp; (B) prove that both the left and right side of the composition law for <code>((-&gt;) r)</code> type reduce to the same statement, and thus the law is proved for the function type.</p>

<h3>Acknowledgements</h3>

<p>Thanks to <a href="http://stackoverflow.com/users/791604/daniel-wagner" title="Stack Overflow User - Daniel Wagner">Daniel Wagner</a> who nudged me in the right direction by answering my questions (<a href="http://stackoverflow.com/questions/33829415/applicative-laws-for-the-r-type" title="Applicative Laws for the ((-&gt;) r) type">1</a> and <a href="http://stackoverflow.com/questions/34538754/proving-composition-applicative-law-for-r-type" title="Proving Composition Applicative law for ((-&gt;) r) type">2</a>) on Stack Overflow.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Applicative Laws for [] Type]]></title>
    <link href="http://umairsd.github.io/blog/2016/01/06/applicative-laws-for-list-type/"/>
    <updated>2016-01-06T05:00:58-08:00</updated>
    <id>http://umairsd.github.io/blog/2016/01/06/applicative-laws-for-list-type</id>
    <content type="html"><![CDATA[<p>This is Part-2 of my series on verifying Applicative laws for various Haskell types. Part-1 is <a href="http://umairsaeed.com/blog/2016/01/05/applicative-laws-for-maybe-type/">Applicative Laws for Maybe Type</a>.</p>

<hr />

<p>Haskell&rsquo;s list type <code>[]</code> is an Applicative functor. Similar to the previous post, this post will verify that the applicative laws hold for the <code>[]</code> type. For reference, <code>[]</code> is made an instance of the <code>Applicative</code> class as:</p>

<pre><code class="haskell">instance Applicative [] where
    pure x      = [x]
    (&lt;*&gt;) fs xs = [f x | f &lt;- fs, x &lt;- xs]
</code></pre>

<!-- more -->


<p>For review, here are the applicative laws:</p>

<ul>
<li><p>Identity: <code>pure id &lt;*&gt; v = v</code></p></li>
<li><p>Homomorphism: <code>pure f &lt;*&gt; pure x = pure (f x)</code></p></li>
<li><p>Interchange: <code>u &lt;*&gt; pure y = pure ($y) &lt;*&gt; u</code></p></li>
<li><p>Composition: <code>pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code></p></li>
</ul>


<p>Now, letâ€™s test the Applicative laws for the <code>[]</code> type one by one:</p>

<h3>Identity</h3>

<p>We need to prove that the following holds for the <code>[]</code> type:</p>

<pre><code class="haskell">pure id &lt;*&gt; v = v
</code></pre>

<p>Consider the <em>left</em> side of the equation:</p>

<pre><code class="haskell">pure id &lt;*&gt; v

-- applying definition of pure for []
[id] &lt;*&gt; v

-- applying definition of &lt;*&gt;
[id x | x &lt;- v]

-- applying id
[x | x &lt;- v]

-- list comprehension reduces to v
v  -- Same as the right side 
</code></pre>

<h3>Homomorphism</h3>

<p>The law&rsquo;s statement is:</p>

<pre><code class="haskell">pure f &lt;*&gt; pure x = pure (f x)
</code></pre>

<p>Starting from the <em>left</em> side:</p>

<pre><code class="haskell">pure f &lt;*&gt; pure x

-- applying definition of pure
[f] &lt;*&gt; [x]

-- Note that both the lists have one element each. So
-- applying the definition of &lt;*&gt;, this reduces to:
[f x]

-- un-applying pure
pure (f x) -- Same as the right side 
</code></pre>

<h3>Interchange</h3>

<p>The law&rsquo;s statement is:</p>

<pre><code class="haskell">u &lt;*&gt; pure y = pure ($y) &lt;*&gt; u
</code></pre>

<p>Starting from the <em>left</em> side,</p>

<pre><code class="haskell">u &lt;*&gt; pure y

-- applying definition of pure 
u &lt;*&gt; [y]   -- A list of functions applied to 
            -- a single element list

-- via definition of &lt;*&gt;
[f y | f &lt;- u]

-- replacing f y by the function application operator
[f $ y | f &lt;- u]

-- Using the section representation of the $ infix operator 
[($y) f | f &lt;- u]

-- Un-applying the definition of &lt;*&gt;
[($y)] &lt;*&gt; u

-- Un-applying pure
pure ($y) &lt;*&gt; u -- Same as the right side
</code></pre>

<h3>Composition</h3>

<p>The law&rsquo;s statement is:</p>

<pre><code class="haskell">pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)
</code></pre>

<p>Starting from the <em>left</em>:</p>

<pre><code class="haskell">pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w

-- applying definition of pure
[(.)] &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w

-- as u, v, w are all lists, for clarity re-writing
-- u as fs, v as gs, w as xs
[(.)] &lt;*&gt; fs &lt;*&gt; gs &lt;*&gt; xs

-- applying definition of &lt;*&gt;
[(.) f | f &lt;- fs] &lt;*&gt; gs &lt;*&gt; xs

-- applying definition of &lt;*&gt;
[z g | z &lt;- [(.) f | f &lt;- fs], g &lt;- gs] &lt;*&gt; xs

-- replace the value of z, and reduce
[(.) f g | f &lt;- fs, g &lt;- gs] &lt;*&gt; xs

-- applying function composition
[f.g | f &lt;- fs, g &lt;- gs] &lt;*&gt; xs

-- applying the definition of &lt;*&gt;
[ z x | z &lt;- [f.g | f &lt;- fs, g &lt;- gs],
        x &lt;- xs]

[ f.g x | f &lt;- fs, g &lt;- gs, x &lt;- xs]

-- applying definition of function composition
[ f (g x) | f &lt;- fs, g &lt;- gs, x &lt;- xs] -- (A)
</code></pre>

<p>In the same manner, let&rsquo;s consider the <em>right</em> side of the equation:</p>

<pre><code class="haskell">u &lt;*&gt; (v &lt;*&gt; w)

-- as u, v, w are all lists, for clarity re-writing
-- u as fs, v as gs, w as xs
fs &lt;*&gt; (gs &lt;*&gt; xs)

-- applying definition of &lt;*&gt;
fs &lt;*&gt; ( [g x | g &lt;- gs, x &lt;- xs] )

-- applying definition of &lt;*&gt;
[f z | f &lt;- fs, z &lt;- [g x | g &lt;- gs, x &lt;- xs] ]

-- replacing z
[f (g x) | f &lt;- fs, g &lt;- gs, x &lt;- xs] -- (B)
</code></pre>

<p>(A) &amp; (B) prove that both the left and right side of the composition law reduce to the same statement, and thus composition law is proved for the <code>[]</code> type</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Applicative Laws for Maybe Type]]></title>
    <link href="http://umairsd.github.io/blog/2016/01/05/applicative-laws-for-maybe-type/"/>
    <updated>2016-01-05T07:32:58-08:00</updated>
    <id>http://umairsd.github.io/blog/2016/01/05/applicative-laws-for-maybe-type</id>
    <content type="html"><![CDATA[<p>Applicative functors come with a set of laws that apply for all Applicative instances. These laws are as follows:</p>

<ul>
<li><p>Identity: <code>pure id &lt;*&gt; v = v</code></p></li>
<li><p>Homomorphism: <code>pure f &lt;*&gt; pure x = pure (f x)</code></p></li>
<li><p>Interchange: <code>u &lt;*&gt; pure y = pure ($y) &lt;*&gt; u</code></p></li>
<li><p>Composition: <code>pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code></p></li>
</ul>


<p>For more information about these laws, check out <a href="https://wiki.haskell.org/Typeclassopedia#Laws_2" title="Applicative Laws">this Haskell wiki post</a>.</p>

<p><code>Maybe</code> is an Applicative functor, and this post will verify that the applicative laws hold for the <code>Maybe</code> instance.</p>

<!-- more -->


<p>Before we begin, let&rsquo;s review the <a href="https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Applicative.html" title="Control.Applicative">definition</a> for <code>Applicative</code> type-class:</p>

<pre><code class="haskell">class Functor f =&gt; Applicative f where
    pure :: a -&gt; f a
    (&lt;*&gt;) :: f (a-&gt;b) -&gt; f a -&gt; f b
</code></pre>

<p><code>Maybe</code> is made an instance of the <code>Applicative</code> class as:</p>

<pre><code class="haskell">instance Applicative Maybe where
    pure x                   = Just x
    (&lt;*&gt;) Nothing  _         = Nothing
    (&lt;*&gt;) (Just f) someMaybe = fmap f someMaybe
</code></pre>

<p>Note that the last line above <a href="http://umairsaeed.com/blog/2015/08/21/maybe-as-an-applicative-functor/" title="Maybe as an Applicative Functor">can be re-written as</a>:</p>

<pre><code class="haskell">    (&lt;*&gt;) (Just f) Nothing  = Nothing
    (&lt;*&gt;) (Just f) (Just x) = Just (f x) 
</code></pre>

<p>Now, let&rsquo;s test the Applicative laws for the <code>Maybe</code> type one by one:</p>

<h3>Identity</h3>

<p>We need to prove that the following holds for the <code>Maybe</code> type:</p>

<pre><code class="haskell">pure id &lt;*&gt; v = v
</code></pre>

<p>Let&rsquo;s start from the <em>left</em> side of the equation:</p>

<pre><code class="haskell">pure id &lt;*&gt; v

-- applying definition of pure for Maybe
(Just id) &lt;*&gt; v
-- v could be either Nothing, or (Just x)
case v of 
    Nothing  -&gt; Nothing 
    (Just x) -&gt; Just (id x)
-- applying id to x is simply x
case v of 
    Nothing  -&gt; Nothing
    (Just x) -&gt; Just x

v  -- the right side of equation
</code></pre>

<h3>Homomorphism</h3>

<p>The law&rsquo;s statement is:</p>

<pre><code class="haskell">pure f &lt;*&gt; pure x = pure (f x)
</code></pre>

<p>To prove this for <code>Maybe</code> type, let&rsquo;s begin from the <em>left</em> side of the equation:</p>

<pre><code class="haskell">pure f &lt;*&gt; pure x

-- applying definition of pure
(Just f) &lt;*&gt; (Just x)
-- applying defintion of &lt;*&gt;
Just (f x)
-- un-applying the definition of pure
pure (f x) -- the right side 
</code></pre>

<h3>Interchange</h3>

<p>The law&rsquo;s statement is:</p>

<pre><code class="haskell">u &lt;*&gt; pure y = pure ($y) &lt;*&gt; u
</code></pre>

<p>Starting from the <em>left</em> side:</p>

<pre><code class="haskell">u &lt;*&gt; pure y

-- applying definition of pure 
u &lt;*&gt; (Just y)

-- u can be either Nothing, or (Just f). Let's evaluate both
case u of 
    Nothing  -&gt; Nothing 
    (Just f) -&gt; Just (f y)

-- re-writing (f y) using function application operator
case u of 
    Nothing  -&gt; Nothing 
    (Just f) -&gt; Just (f $ y)

-- Using the section representation of the $ infix operator 
case u of 
    Nothing  -&gt; Nothing
    (Just f) -&gt; Just (($y) f)

-- Un-applying the definition of &lt;*&gt;
case u of 
    Nothing  -&gt; Nothing
    (Just f) -&gt; Just ($y) &lt;*&gt; (Just f)

-- Replacing the Nothing clause with an equivalent (via 
-- the defintion) of &lt;*&gt; for Maybe
case u of 
    Nothing  -&gt; Just ($y) &lt;*&gt; Nothing  
    (Just f) -&gt; Just ($y) &lt;*&gt; (Just f)

-- Un-applying the definition of pure and u
pure ($y) &lt;*&gt; u -- Equal to the right side
</code></pre>

<h3>Composition</h3>

<p>The law&rsquo;s statement is:</p>

<pre><code class="haskell">pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)
</code></pre>

<p>Starting from the <em>left</em> side:</p>

<pre><code class="haskell">pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w

-- applying definition of pure
(Just (.)) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w

-- u, v &amp; w can all be either Nothing or (Just something). 
-- From the definition of &lt;*&gt;, we know that if either 
-- argument to &lt;*&gt; is Nothing, the entire expression reduces
-- to Nothing. 
-- Therefore, I am only going to focus on the Just cases
(Just (.)) &lt;*&gt; (Just f) &lt;*&gt; (Just g) &lt;*&gt; (Just x)

-- Appying &lt;*&gt; to the first two terms
(Just (.) f) &lt;*&gt; (Just g) &lt;*&gt; (Just x)

-- Appying &lt;*&gt; to the first two terms again
(Just (.) f g) &lt;*&gt; (Just x)

-- Applying the function composition
(Just (f.g) ) &lt;*&gt; (Just x)

-- Applying &lt;*&gt; one more time
(Just (f.g) x)

-- via the definition of the function composition 
-- operator
(Just f (g x))

-- Applying Homomorphism law
(Just f) &lt;*&gt; Just (g x)

-- Applying Homomorphism law to the 2nd term
(Just f) &lt;*&gt; ( (Just g) &lt;*&gt; (Just x) )

-- Un-applying the definitions of u, v, w
u &lt;*&gt; (v &lt;*&gt; w)    -- Equal to the right side
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maybe as an Applicative Functor]]></title>
    <link href="http://umairsd.github.io/blog/2015/08/21/maybe-as-an-applicative-functor/"/>
    <updated>2015-08-21T09:53:20-07:00</updated>
    <id>http://umairsd.github.io/blog/2015/08/21/maybe-as-an-applicative-functor</id>
    <content type="html"><![CDATA[<p><code>Maybe</code> type is made an instance of the <code>Applicative</code> type class as follows (<a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors" title="Learn You a Haskell for Great Good, Applicative Functors">link</a>):</p>

<pre><code class="haskell">instance Applicative Maybe where
    pure = Just
    Nothing &lt;*&gt; _ = Nothing
    (Just f) &lt;*&gt; something = fmap f something
</code></pre>

<p>It took me a several attempts before I could parse this definition. I was particularly puzzled by the line <code>(Just f) &lt;*&gt; something = fmap f something</code>. To help me understand this better, I decided to build this definition back up from the very basics.</p>

<!-- more -->


<p>First, let&rsquo;s look at the <code>Functor</code> type class definition:</p>

<pre><code class="haskell">class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

<p>This means that for a given functor type <code>f</code> (i.e. type that is an instance of the <code>Functor</code> type class), <code>fmap</code> takes a function from <code>a -&gt; b</code> and a functor (box) that contains <code>a</code> and returns a functor (box) that contains <code>b</code>. An intuitive way to think about this is that <code>fmap</code> opens the box containing <code>a</code> and applies the function <code>a -&gt; b</code> to it, which results in <code>b</code>.</p>

<p>Now let&rsquo;s see how <code>Maybe</code> is an instance of the <code>Functor</code> type class:</p>

<pre><code class="haskell">instance Functor Maybe where
    fmap func Nothing  = Nothing
    fmap func (Just x) = Just (func x)
</code></pre>

<ul>
<li>Line 2: Applying a function to <code>Nothing</code> results in <code>Nothing</code>.</li>
<li>Line 3: From the definition of the <code>Functor</code> type, we know that the type of <code>func</code> is <code>a -&gt; b</code> and <code>Just x</code> corresponds to <code>f a</code>. Applying the function to <code>x</code> inside the box results in a value of type <code>b</code> in the functor box.</li>
</ul>


<p>Now, let&rsquo;s look at the definition of the <code>Applicative</code> type class:</p>

<pre><code class="haskell">class (Functor f) =&gt; Applicative f where  -- 1
    pure :: a -&gt; f a                      -- 2
    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b     -- 3
</code></pre>

<p>For a type <code>f</code> that is an instance of the <code>Applicative</code> type class, here is what each line means:</p>

<ol>
<li><code>f</code> must also be a functor (i.e. be an instance of the <code>Functor</code> type class).</li>
<li>The <code>pure</code> function takes an arbitrary type <code>a</code> and brings it into the functor. i.e. <code>pure</code> puts <code>a</code> in a box of type <code>f</code>.</li>
<li><code>&lt;*&gt;</code> takes a functor (box) of type <code>f</code> that contains a function of type <code>a -&gt; b</code>, and a functor (box) of type <code>f</code> that contains type <code>a</code>. It results in a functor (box) of type <code>f</code> that contains <code>b</code>.</li>
</ol>


<p>With the preamble out of the way, let&rsquo;s make <code>Maybe</code>  an instance of the <code>Applicative</code> type class. To do that, I need to implement the <code>pure</code> and <code>&lt;*&gt;</code> methods for the <code>Maybe</code> type. Below is a line-by-line implementation:</p>

<pre><code class="haskell">instance Applicative Maybe where
    pure x = Just x
</code></pre>

<p>For the <code>Maybe</code> type, <code>pure</code> simply wraps an arbitrary type in <code>Just</code>, thus making it a <code>Maybe</code> value. E.g. writing <code>pure 4 :: Maybe Int</code> in GHCi results in <code>Just 4</code>.</p>

<pre><code class="haskell">    (&lt;*&gt;) Nothing _ = Nothing
</code></pre>

<p>Here, <code>Nothing</code> maps to <code>f (a -&gt; b)</code> from the <code>Applicative</code> class definition. We cannot extract a function out of <code>Nothing</code>, so the result will be <code>Nothing</code> regardless of the second argument.</p>

<pre><code class="haskell">    (&lt;*&gt;) (Just func) Nothing = Nothing
</code></pre>

<p>In the line above, <code>(Just func)</code> maps to <code>f (a -&gt; b)</code>, and <code>Nothing</code> maps to <code>f a</code> from the class definition. <code>&lt;*&gt;</code> extracts <code>func</code> out of <code>Just func</code>, and applies it to <code>Nothing</code>. Applying a function to <code>Nothing</code> results in <code>Nothing</code> (or, using the box analogy, applying a function to an empty box results in an empty box)</p>

<pre><code class="haskell">    (&lt;*&gt;) (Just func) (Just x) = Just (func x) 
</code></pre>

<p><code>(Just func)</code> maps to <code>f (a -&gt; b)</code>, and <code>Just x</code> maps to <code>f a</code> from the <code>Applicative</code> class definition. <code>&lt;*&gt;</code> extracts the function from <code>Just func</code>, and applies it to <code>x</code> inside the <code>Just x</code> box. The result is <code>Just (func x)</code>.</p>

<p>Now, let&rsquo;s put the definition of <code>&lt;*&gt;</code> for <code>Maybe</code> type next to the definition of the <code>fmap</code> function:</p>

<pre><code class="haskell">    (&lt;*&gt;) (Just func) Nothing  = Nothing
    (&lt;*&gt;) (Just func) (Just x) = Just (func x) 

    fmap func Nothing  = Nothing
    fmap func (Just x) = Just (func x)
</code></pre>

<p>This makes it obvious that in the definition of <code>&lt;*&gt;</code>, once we extract <code>func</code> out of <code>Just func</code>, we simply map that function over the second argument of <code>&lt;*&gt;</code> (which will be of <code>Maybe</code> type as well). This means that the <code>&lt;*&gt;</code> implementation for <code>Maybe</code> can be re-written as:</p>

<pre><code class="haskell">    &lt;*&gt; (Just func) something = fmap func something
</code></pre>

<p>This is exactly how the <code>&lt;*&gt;</code> function is implemented at the beginning of this blog post.</p>

<p>Finally, <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" title="Functors, Applicatives, And Monads in Pictures">Functors, Applicatives, And Monads In Pictures</a> by <a href="https://twitter.com/_egonschiele" title="Aditya Bhargava's Twitter Page">Aditya Bhargava</a> is one of the best posts I&rsquo;ve read on functors &amp; applicatives. I highly recommend it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pascal's Triangle]]></title>
    <link href="http://umairsd.github.io/blog/2015/07/08/pascals-triangle/"/>
    <updated>2015-07-08T06:51:27-07:00</updated>
    <id>http://umairsd.github.io/blog/2015/07/08/pascals-triangle</id>
    <content type="html"><![CDATA[<p>One of the exercises in <a href="https://mitpress.mit.edu/sicp/">Structure and Implementation of Computer Programs</a> deals with generating elements of the <a href="https://en.wikipedia.org/wiki/Pascal's_triangle">Pascal&rsquo;s Triangle</a>. The following pattern of numbers is called <em>Pascal&rsquo;s Triangle</em></p>

<pre><code>
    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1
...
</code></pre>

<p>The numbers at the edge of the triangle are 1, and each number inside is the sum of two numbers above it. The exercise asks us to <em>find the elements of Pascal&rsquo;s triangle by means of a recursive process</em>.</p>

<!-- More -->


<p>I find it helpful to <em>de-skew</em> the triangle so that the rows and columns line up visually. Here&rsquo;s the modified triangle:</p>

<pre><code>
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
...
</code></pre>

<p>I decided to write the solution in Haskell, and here it is:</p>

<pre><code class="haskell">-- A: Function that finds the element of Pascal's Triangle for a given row &amp; column
pascal :: Int -&gt; Int -&gt; Int
pascal 0 _ = 1
pascal _ 0 = 1
pascal row col
    | row == col = 1
    | col &gt; row  = error "Column can't be greater than row"
    | otherwise  = (pascal (row-1) (col-1)) + (pascal (row-1) col)
</code></pre>

<p>This code is great for generating the element at a given row and column (e.g. <code>pascal 3 2</code> produces <code>3</code>), but not so great if we wanted to generate the entire triangle up to <code>n</code> rows, as we would recursively generate the elements at row <code>n-1</code> multiple times.</p>

<p>In order to generate the entire triangle, it is better to do it via an iterative process as follows: generate the first row, and from that generate the second row, and so on. I other words, we are generating the next row of the triangle, by adding each pair in the current row. My solution is as follows:</p>

<pre><code class="haskell">-- Takes an array of integers, and adds pairs of numbers to create a new 
-- array. For example, [1,2,3,4] changes to [(1+2), (2+3), (3+4)], resulting
-- in [3,5,7]
sumOfPairs :: [Integer] -&gt; [Integer]
sumOfPairs [] = []
sumOfPairs (x:[]) = []
sumOfPairs (x:y:ys) = (x+y) : sumOfPairs (y:ys)


-- Given a row of Pascal's triangle, returns the next row
next :: [Integer] -&gt; [Integer]
next xs = 1 :  (sumOfPairs xs) ++ [1]


-- Generates the Pascal's triangle. This function generates an
-- infinite triangle, so its usage needs to be coupled with the 
-- take command. For example: take 5 pascalTriangle
pascalTriangle :: [[Integer]]
pascalTriangle = pascalHelper [1]
    where pascalHelper xs = xs : pascalHelper (next xs)
</code></pre>

<p>Here are a couple of examples of generating the triangle:</p>

<pre><code class="haskell">*Main&gt; take 4 pascalTriangle 
[[1],[1,1],[1,2,1],[1,3,3,1]]

-- Using mapM_ with print to 'pretty-print' the triangle
*Main&gt; mapM_ print $ take 8 pascalTriangle
[1]
[1,1]
[1,2,1]
[1,3,3,1]
[1,4,6,4,1]
[1,5,10,10,5,1]
[1,6,15,20,15,6,1]
[1,7,21,35,35,21,7,1]
</code></pre>

<p>The function <code>pascalTriangle</code> can be made more concise by using the built-in <code>iterate</code> instead of my <code>pascalHelper</code>:</p>

<pre><code class="haskell">pascalTriangle :: [[Integer]]
pascalTriangle = iterate next [1]
</code></pre>

<p>By this point, I was reasonably satisfied with the code. However, being relatively new to Haskell, I decided to explore and see if there were other (and possibly better and more idiomatic) ways to solve this problem. My favorite was by <a href="http://neilmitchell.blogspot.com/2012/01/pascals-triangle-in-haskell.html">Neil Mitchell</a>, who solved the problem in two lines! I encourage you to go read <a href="http://neilmitchell.blogspot.com/2012/01/pascals-triangle-in-haskell.html">Neil&rsquo;s entire post</a>. Here&rsquo;s the two-line version of Haskell&rsquo;s triangle:</p>

<pre><code class="haskell">-- By: Neil Mitchell 
-- (http://neilmitchell.blogspot.com/2012/01/pascals-triangle-in-haskell.html)

next xs = zipWith (+) ([0] ++ xs) (xs ++ [0])
pascal = iterate next [1]
</code></pre>

<p>In my view, this code is very elegant and beautiful and does a great job of highlighting the power of Haskell.</p>
]]></content>
  </entry>
  
</feed>
